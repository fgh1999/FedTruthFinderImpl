syntax = "proto3";
package algo;
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

// `identifier` is a string that can almost universally represent the event
message EventRegistrationRequest {
    string identifier = 1;
}

message EventRegistrationResponse {
    uint64 eid = 1;
}

message InitRequest {
    bytes pk = 1;
    string mailbox = 2; //string-form address of the client mailbox
}
message InitResponse {
    int32 uid = 1;  //user id
    int32 gid = 2;  //group id
}

message RandCoefShareNotification {
    uint64 eid = 1;     // for sync
    int32 clientNum = 2;
    int32 groupNum = 3;
    bytes share = 4;    // a share of a random coefficient
    int32 gid = 5;      // which group the random coefficient generated from
}
message RandCoefSharePubRequest {
    int32 topic_gid = 1;
    int32 txUid = 2;
    int32 rxUid = 3;
    RandCoefShareNotification notification = 4;
}

message TauSeqShareNotification {
    uint64 eid = 1;     //for sync
    int32 clientNum = 2;
    int32 groupNum = 3;
    bytes share = 4;    // a share of a tau_sequence
    int32 uid = 5;      // which client the tau belongs to
}
message TauSeqSharePubRequest {
    int32 topic_gid = 1;
    int32 txUid = 2;
    int32 rxUid = 3;
    TauSeqShareNotification notification = 4;
}

message RelayMessage {
    int32 txUid = 1;
    int32 rxUid = 2;
    int32 clientNum = 3;
    uint64 eid = 4;
    bytes encryptedMessage = 5;
}

message HSetShareMessage {
    int32 txUid = 1;
    int32 rxUid = 2;
    int32 clientNum = 3;
    uint64 eid = 4;
    bytes encryptedMessage = 5;
    int32 txGid = 6;
}

message SubmitSummationRequest {
    uint64 eid = 1;             // which event is under process
    bytes summationPair = 2;   // [\hat{d_j^k}, \hat{s_j^k}] => Share<Rational>
    double allowedSeconds = 3;  // Time limitation for return
}

message EventConfidenceComputationConfigRequest {
    uint64 eid = 1;
}
message EventConfidenceComputationConfig {
    map<int32, bytes> clientsPk = 1; // map<Uid, pk> 
    int32 threshold = 2;
}

message LeaderBoardComputationConfigRequest {
    uint64 eid = 1;
}
message LeaderBoardComputationConfig {
    map<int32, int32> clients = 1; // map<Uid, Gid>
}

message HApoShare {
    uint64 eid = 1;
    double allowedSeconds = 2;
    bytes share = 3;
}
message LeaderBoard {
    // the leader-board is ranked ascendingly by the clients' trustworthiness
    repeated int32 clients = 1;
}

service Master {
    //client apply a identity from the server and registerate its pk on the server
    //server init a new identity according to the given pk; otherwise, return Status::already_exists
    rpc Register(InitRequest) returns (InitResponse) {}

    // Find the event on the server.
    // If already exists, return its eid on the server;
    // Or, registrate it to new a eid and return it. 
    rpc FindOrRegisterEvent(EventRegistrationRequest) returns (EventRegistrationResponse) {}

    // Publish to subscribers
    rpc PublishTauSequence(TauSeqSharePubRequest) returns (google.protobuf.Empty) {}
    rpc PublishR(RandCoefSharePubRequest) returns (google.protobuf.Empty) {}
    rpc ForwardHShare(HSetShareMessage) returns (google.protobuf.Empty) {}

    //Forward the message until it reached rxUid.
    //When the target receiver receive the message, it can push it into a channel.
    rpc Forward(RelayMessage) returns (google.protobuf.Empty) {}

    // submit the result of client-side summation and await a feedback(confidence of the processing event)
    rpc SubmitSummation(SubmitSummationRequest) returns (google.protobuf.DoubleValue) {}

    // submit the result of client-side H set and await a feedback(leader-board of clients) 
    rpc SubmitHApoShare(HApoShare) returns (LeaderBoard) {}

    //Return the number of groups on the server
    rpc GetGroupNum(google.protobuf.Empty) returns (google.protobuf.Int32Value) {}

    rpc GetEventConfidenceComputationConfig(EventConfidenceComputationConfigRequest) returns (EventConfidenceComputationConfig) {}

    rpc GetLeaderBoardComputationConfig(LeaderBoardComputationConfigRequest) returns (LeaderBoardComputationConfig) {}
}

message Selection {
    uint64 eid = 1;
    int32 groupNum = 2;
    int32 clientNum = 3;
}

// for test
message EventNotification {
    string identifier = 1;
}

service Slave {
    //Forward the message until it reached rxUid.
    //When the target receiver receive the message, it can push it into a channel.
    rpc Forward(RelayMessage) returns (google.protobuf.Empty) {}

    // Select a client to do 
    rpc SelectToShareR(Selection) returns (google.protobuf.Empty) {}
    rpc SelectToShareHSet(Selection) returns (google.protobuf.Empty) {}

    // Being notified because of having registered
    rpc NotifyTauSequence(TauSeqShareNotification) returns (google.protobuf.Empty) {}
    rpc NotifyR(RandCoefShareNotification) returns (google.protobuf.Empty) {}
    rpc SendHShare(HSetShareMessage) returns (google.protobuf.Empty) {}

    // for test, returns self.uid
    rpc Handle(EventNotification) returns (google.protobuf.Int32Value) {}
}
